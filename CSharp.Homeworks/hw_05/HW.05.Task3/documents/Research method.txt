Встроенный метод Reverse имеет две перегрузки. Вызывая первую перегрузку мы передаём только массив. Внтри метода вызывается вторая перегрузка метода Reverse с дефолтными
значениями в параметрах. Параметры: Сам массив, индекс нулевой и самоопределившаяся длинна массива. Далее создаются переменный index1 и index2. index1 инициализируется значением
индекса 0, index2 в нашем случае принимает номер последнего индекса. Далее отрабатывает цикл for пока index2 больше index1 и отнимается 1 от index2 каждую итерацию, а
к index1 прибавляется.

В самом цикле гениальная логика, каждая итерация изменяет массив с начала и конца. Изменения начинаются с 0 и последнего индекса одновременно в рамках одной итерации
цикла и при каждой новой итерации смещаются отредактированные ячейки на 1. С начала цикла на одну больше, а с конца цикла на одну меньше. Будто по логике ячейки стремятся
друг к другу.

        int[] myArray = {1,2,3,4}

        for (; index1 < index2; --index2)      | index2 = 3   | index2 = 2    | index1 = 2 и index2 = 2  >>>> Цикл прерывается и во второй итерации достигнут реверс
        {                                      |              |               |
          object obj = objArray[index1];       | obj = 1      | obj = 2       |
          objArray[index1] = objArray[index2]; | (4)/ 2/ 3/ 4 | (4)/(3)/ 3/ 1 |
          objArray[index2] = obj;              | 4/ 2/ 3/ (1) | 4/ 3/ (2)/(1) |
          ++index1;                            | index1 = 1   | index1 = 2    |
        }    


Вывод:
Мой реверс более ресурсозатратный и более примитивный. В системном методе изменения происходят в двух индексах за одну итерацию, нет временного
массива, память не выделяется на новый массив тем самым экономится ресурс. Не происходит дополнительного копирования в другой массив, все изменения происходят
в рамках одного масива. 

Но почему мой оказался шустрее, у меня на это ответа нет. :(                                       